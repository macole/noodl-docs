---
title: データベースクエリのフィルタリング
hide_title: true
---

# データベースクエリのフィルタリング

## このガイドで学べること

このガイドでは、**レコード**のフィルタリングされたクエリをデータベースにさせる方法を学びます。これはアプリで一般的に行われるタスクです。たとえば、特定の投稿に関連するコメントのみを表示したい場合や、未読のメッセージをすべて表示したい場合などです。これは、データベースにクエリを実行して、選択された結果のみをフィルタリングするように依頼することで実現されます。

Noodlでは、フィルタリングされたクエリを作成するために[クエリレコード](/nodes/data/cloud-data/query-records)ノードを使用します。

## 概要

このガイドでは、以下のステップを説明します：

-   特定の値に等しいプロパティを持つ**レコード**のデータベースクエリ
-   動的フィルタリングを行う、つまりクエリフィルターを動的に変更する

このガイドを最大限に活用するには、クラウドバックエンドの設定、**クラス**と**レコード**の作成、基本的なクエリの実行方法に既に慣れていることが最適です。以下のガイドを通じて、それをすばやく学ぶことができます：

-   [バックエンドの作成](/docs/guides/cloud-data/creating-a-backend)
-   [クラスの作成](/docs/guides/cloud-data/creating-a-class)
-   [レコードの作成](/docs/guides/cloud-data/creating-new-database-records)
-   [レコードのクエリ](/docs/guides/cloud-data/quering-records-from-database)
-   [レコードの更新](/docs/guides/cloud-data/updating-records)

## クラウド内のレコードのフィルタリング vs ローカルでのフィルタリング

このガイドでは、クラウドデータベース内のクエリをフィルタリングすることに焦点を当てています。つまり、**レコード**はアプリにネットワーク経由で送信される前にフィルタリングされます。これが[クエリレコード](/nodes/data/cloud-data/query-records)ノードが行うことです。

また、すでにアプリ内にあるデータをフィルタリングする別のノード、[フィルタレコード](/nodes/data/cloud-data/filter-records)もあります。つまり、ローカルでフィルタリングします。

これらの方法はそれぞれ利点と欠点があり、良いアプリではしばしばこれらを組み合わせて使用します。

データベース内でクエリをフィルタリングする（**クエリレコード**を使用する）利点は次のとおりです：

-   ネットワークを介してフィルタリングされた**レコード**のみが送信されます。これは、大量のデータを扱う場合に非常に重要です。データベースに数千の製品がある場合、ユーザーが検索している製品のみを送信したいですし、そうでなければアプリが遅くなります。

-   例えば、特定のオブジェクトのみをソートまたはフィルタリングする場合に、データベースの最適化されたインデックスを利用できます。再び、数千または数百万の**レコード**を扱う大量のデータセットで作業する場合、これはアプリを高速にする鍵となります。

クエリをローカルでフィルタリングする（**フィルタレコード**を使用する）主な利点は次のとおりです：

-   **レコード**がアプリに一度入ると、ネットワーク経由で**レコード**を送信する必要がなくなり、アプリがはるかに高速になります。

-   アプリのユーザーが多い場合、バックエンドとデータベースが混雑する可能性があります。たとえば、データをローカルで処理することによって、クラウドデータベースへのクエリを頻繁に避けることで、それにかかる負荷を減らすことができます。

最適なソリューションは、しばしばこれら2つの方法を組み合わせることです。データベースに対してフィルタリングされたクエリを行い、アプリに送信される**レコード**の量を合理的な数に絞り込み、その後で**フィルタレコード**を使用してローカルで追加のフィルタリングとソートを行います。

このガイドでは、**クエリレコード**ノードを使用したフィル

タリングに特に焦点を当てています。**フィルタレコード**ノードは非常に類似した方法で動作しますが、**クエリレコード**ノードからの**レコード**の**配列**など、すでにアプリにある**レコード**の**配列**にのみ作用します。

## フィルタリングのためのクエリレコードノードの使用

このガイドでは、少なくとも1つのクラスがあり、いくつかの**レコード**を含むバックエンドがすでに稼働していることを前提としています。それに関するヘルプが必要な場合は、以前の「クラウドデータの操作」ガイドを参照してください。例として、以前のガイドで作成されたシンプルなタスクアプリを使用します。`Task`という1つの**クラス**があります。これには、タスクの説明である`task`プロパティと、タスクが完了したかどうかを追跡するブール値`isDone`プロパティがあります。

<div className="ndl-image-with-background l">

![](/docs/guides/cloud-data/filtering-database-queries/checkbox-anim.gif)

</div>

アプリのメイン画面は以下のようになります：

<div className="ndl-image-with-background l">

![](/docs/guides/cloud-data/filtering-database-queries/orig-app.png)

</div>

各todo**レコード**は以下のように構成されたリストアイテムによって表されます：

<div className="ndl-image-with-background l">

![](/docs/guides/cloud-data/filtering-database-queries/list-item-2.png)

</div>

これで、未完了のタスクのみを表示するフィルターを追加したいと考えています。メイン画面の**クエリレコード**ノードをクリックしてから、`フィルタールールを追加`ボタンをクリックします。

<div className="ndl-image-with-background">

![](/docs/guides/cloud-data/filtering-database-queries/add-filter-rule-1.png)

</div>

フィルターを構築できる新しいポップアップが表示されます。少し試してみてください。

<div className="ndl-image-with-background">

![](/docs/guides/cloud-data/filtering-database-queries/add-filter-rule-2.png)

</div>

基本的に3つの部分があります：

`<プロパティ> <演算子> <値または入力>`

`<プロパティ>`は、例えば私たちのタスク例の`isDone`のように、**レコード**のプロパティです。

`<演算子>`は、条件の論理演算子です。さまざまな演算子があり、すべてのプロパティタイプですべての演算子が使用可能というわけではありません。
`isDone` - **ブール値**の場合、使用可能な演算子は`等しい`、`等しくない`、`存在する`、`存在しない`の4つです。`等しい` / `等しくない`は自明ですが、`存在する` / `存在しない`演算子は次のように機能します：プロパティに値が設定されているか、または未定義かどうかをチェックします。

最後に、`<値または入力>`は、演算子を適用する値です。`<入力>`オプションは後で見るので、今のところは`<値>`を使用しましょう。

このケースでは、`isDone = false`である、つまりまだ完了していないタスクのみをフィルタリングしたいと考えています。したがって、私たちのフィルターは次のようになります：

`<isDone> <等しい> <false>`

それを選択しましょう。フィルターのやや難解な形式が、フィルターの下に自然言語で書き出されているのを見ることができます。

<div className="ndl-image-with-background">

![](/docs/guides/cloud-data/filtering-database-queries/add-filter-rule-3.png)

</div>

あなたのアプリのリストが未完了のタスクのみを表示するように変更されているのがすでに見えるはずです（あなたがそれを持っている場合）。タスクをチェックすると、それらが1つずつ消えていくのが見えるはずです。それらを戻したい場合は、**ダッシュボード**に行って`isDone`値を再び`false`に変更し、アプリをリフレッシュする必要があります。

<div className="ndl-image-with-background l">

![](/docs/guides/cloud-data/filtering-database-queries/completing-tasks.gif)

</div>

## 動的フィルタリング

アプリの現在の状態は明らかに欠陥があります - すべてのタスクを完了すると何も表示されません。完了したタスクと未完了のタスクのビューを切り替えることができる必要があります。

[ラジオボタングループ](/nodes/ui-controls/radio-button-group)と2つの[ラジオボタン](/nodes/ui-controls/radio-button)を追加しましょう。これにより、未完了のタスクを表示するか、完了

したタスクを表示するかを制御できます。

<div className="ndl-image-with-background l">

![](/docs/guides/cloud-data/filtering-database-queries/radiobutton-1.png)

</div>

<div className="ndl-image-with-background">

![](/docs/guides/cloud-data/filtering-database-queries/radiobutton-2.png)

</div>

ボタンのラベルが正しく設定されていること（"未完了を表示" / "完了を表示"）、それぞれの値が"未完了" / "完了"に設定されていることを確認してください。また、**ラジオボタングループ**の**値**は"未完了"になっています。これがデフォルトの状態になります。**ラジオボタングループ**の**値**の出力を使用して、**クエリレコード**のフィルタ設定を制御します。

**クエリレコード**ノードのフィルターを入力を使用して制御できるように更新しましょう。**クエリレコード**ノードをクリックして、フィルターの最後の部分を値ではなく**入力**に変更します。

<div className="ndl-image-with-background l">

![](/docs/guides/cloud-data/filtering-database-queries/add-filter-rule-4.png)

</div>

入力に"isDoneFilter"という名前を付けます。これで、**クエリレコード**に新しい入力が使用できるようになりました！入力が`true`に設定されている場合、完了したタスク（`isDone = true`）のみがフィルタリングされ、`false`の場合はその逆になります。

最後に、2つのラジオボタンの値"未完了"と"完了"を`true`または`false`に変換する必要があります。これは、[式](/nodes/math/expression)ノードを作成し、式を

`filterState === "Completed"`

と設定することで行います。**式**ノードの出力は、入力が"完了"の場合は`true`、それ以外の場合は`false`になります。最後に、**式**の出力を**クエリレコード**に接続します - そして、ラジオボタンをクリックするとフィルタリングが切り替わります。

<div className="ndl-image-with-background l">

![](/docs/guides/cloud-data/filtering-database-queries/radiobutton-3.png)

</div>

<div className="ndl-image-with-background l">

![](/docs/guides/cloud-data/filtering-database-queries/radiobutton-ui.gif)

</div>